# datayi
datayi 数易数据运营系统

**数据运营系统**<br />
包含：
- 数据采集汇聚
- 数据仓库
- 用户画像
- OLAP平台
- web前端（开发中，进入目录，另开窗口运行）
- web后端（开发中，进入目录，另开idea窗口运行）

# 数据汇聚采集（行为日志）

## 数据类型

### 用户行为日志
- App端行为日志
- 微信小程序端行为日志
- Web端行为日志

### 业务数据
- 交易域（订单相关统计）
- 营销域（优惠券，促销活动）
- 会员域（会员等级，会员消费统计）

<br />

## 数据产生

行为日志：前端埋点（app端，微信小程序端，web端），产生在日志服务器的磁盘文件中<br />业务数据：业务系统所产生的，通常产生在业务系统的数据库中<br /><br />

## 数据采集

利用flume采集（taildir-source，file-channel，hdfs-sink）<br />如何解决跨机房跨网络（采用级联方式 上游 ：12个agent ；下游：4个collector ）<br />如何解决级联时的下游agent高可用（下游的每一个agent都有一个备用机，上游的agent都配置failover sink策略）<br /><br />自定义了拦截器，抽取事件的时间作为header时间戳以便于分发到正确的日期文件夹中；<br />自定义了拦截器，对数据中的敏感字段进行脱敏处理；<br /><br />Flume如何监控？Flume自身有上报metric的机制，可以暴露一个http端口用json数据上报，也可以上报给ganglia等外部监控系统；<br /><br />

# 数仓的ODS层（行为日志）

**建表模型**：与相应类型的日志数据字段结构一致<br />**底层存储格式**： json数据格式<br />**Json数据如何解析**： jsonSerDe<br />**存储周期（时长）**：ods层通常存储3个月（非严格标准，有些公司存6个月，也有存1年的，还有那种很懒惰的：啥时候空间不够了，再删掉一部分老数据）<br /><br />技术工作：

```
load data inpath  ‘app/hdfs/path’  into table t_xxx parition(dt=’20200110’)
load data inpath  ‘wx/hdfs/path’  into table t_xxx parition(dt=’20200110’)
load data inpath  ‘web/hdfs/path’  into table t_xxx parition(dt=’20200110’)
load data inpath  ‘h5/hdfs/path’  into table t_xxx parition(dt=’20200110’)
```

<br />开发成脚本，放入调度系统自动调度<br />

# 数仓的DWD层（行为日志）

**主要目标：**清洗过滤、数据集成（地理位置信息）、guid标识、session分割、数据打平（扁平表结构，parquet文件）<br /><br />

## 铺垫工作

### 地理位置信息集成

地理位置信息的知识库（字典）-- geohash，省，市，区  --用了工具：geohash<br />Ip地址地理位置信息字典，  -- (ipLong1,ipLong2)，省，市，区 --用了工具：ip2region<br />

### Guid标识

设备-账号，关联评分表；<br /> 目的？日志中出现的匿名访问记录，该归属给谁<br /> ——该设备关联评分最高的账号作为guid；<br />如果没有关联过任何账号，那么设备号作为guid<br /> 如果“设备-账号”组合T-1有，T日无，则评分衰减<br /> —— 从T日的日志中，聚合出，每个设备，关联的账号的会话次数（评分）

| 设备id | 账号 | 评分 |
| ------ | ---- | ---- |
|        |      |      |
|        |      |      |
|        |      |      |

<br /> —— 将上表与T-1日的关联评分表full join，分情况取值：<br /> 如果“设备-账号”组合T-1有，T日有，则评分累加<br /> 如果“设备-账号”组合T-1有，T日无，则评分衰减<br /> 如果“设备-账号”组合T-1无，T日有，则新增记录<br /><br />

### 全局guid记录表（添加自增id）

目的？ 判断新老访客；给每个访客一个持久不变的唯一自增id（bitmap等算法需要）<br />实现逻辑：从当天处理好的dwd日志数据结果中，取出新访客的guid，生成 row_number+（T-1日max(id) ）作为自增id，然后插入T-1日的全局guid记录表<br /><br />

## 主处理程序

清洗过滤：根据清洗过滤的规则，进行判断<br /><br />数据集成：从当前的行中，取出经纬度，利用geohash工具转成geohash码，去geohash字典中查询省市区信息，如果查询失败，则利用ip地址从ip2region字典中查询；还查询失败，则省市区置为“UNKNOWN”；并将查询失败的gps坐标，单独分出存储到一个表中，以待日后通过高德开发api获取省市区信息，填补完善我们自己的geohash字典<br /><br />Guid标识：从当前行中取account和deviceid，如果有account，则guid=account<br />如果没有account，则拿deviceid去关联评分字典查询account，让guid=查询到的account；如果查询失败，则guid=deviceid<br /><br />新老访客标记：拿当前行的guid，去“全局guid标识表 T-1日”中匹配，匹配不到的为新用户，否则为老用户；<br /><br /><br />l session分割： 用rdd来写<br />rdd.groupBy(session号)<br /> .mapValues(一组数据==>{<br /> 对这一组数据按照时间排序<br /> 循环遍历：<br />然后判断i 和 i+1两条事件的时间间隔：<br />如果>30分钟，则生成新的sessionid，否则延续上一个<br />}<br />)<br /><br />l 保存parquet结果<br />l 挑出新访客的guid，插入“全局guid记录表”中<br /><br /><br />

## 日活明细表开发

可以单独维护一张“日活表”

| 分区日期 | guid |
| -------- | ---- |
|          |      |
|          |      |

<br />逻辑，有两种选择：<br />1. 从ods计算到dwd的程序中，对当日出现的所有guid去重后，插入目标表<br />2. 从流量会话聚合表中，对当日出现的所有guid去重后，插入目标表<br />

## 思想总结

什么叫map端join？和广播变量有啥联系？<br />Spark中的广播变量，就是map端join的具体实现技术手段！<br />在mapreduce中，map端join的技术手段是通过distributedCache来实现（分布式缓存文件）<br /><br />数仓中的表为什么要分层管理？<br />方便管理，计算链条之间的解耦，可以提高计算复用度，降低复杂需求的开发难度<br />一般分哪些层：

- ods层（贴源层）
- dw层（数据仓库层；内部又可以分为dwd、dws层）
- ads层（应用层）

<br />Dwd层的数据存储周期？一般存储6-12个月（非严格标准）<br /><br />

# 数仓的DWS层（行为日志）

Dws层的主要功能：数据服务层；服务上层的计算；<br />Dws层的主要建模思想：汇总表（宽表）；轻度聚合表；<br />

## 流量分析

### 流量（访问量）会话聚合表

主要逻辑：<br />根据newsessionid分组，聚合<br />求出每个回话的：起始时间，结束时间，访问页面数(pv)，入口页，跳出页<br />

| 分区日 | GUID | 会话ID | 起始时间 | 结束时间 | 访问页数 | 入口页 | 退出页 | 新老标记 | 小时段 | 省   | 市   | 区   | 手机型号 |
| ------ | ---- | ------ | -------- | -------- | -------- | ------ | ------ | -------- | ------ | ---- | ---- | ---- | -------- |
|        | g01  | s01    |          |          |          |        |        |          |        |      |      |      |          |
|        | g01  | s02    |          |          |          |        |        |          |        |      |      |      |          |

表名： dws.tfc_app_agr_session<br />这个需求中，略麻烦的是，各种维度字段值的提取；我们用了first_value over窗口函数<br /><br /><br />

### 流量用户聚合表

| 分区日 | GUID | 会话次数 | 跳出数 | 访问时长 | 访问页数 | 新老标记 | 省   | 市   | 区   | 手机型号 | App版本 | 网络类型 |
| ------ | ---- | -------- | ------ | -------- | -------- | -------- | ---- | ---- | ---- | -------- | ------- | -------- |
|        | g01  | 3        |        |          |          |          | A1   | B1   | C1   |          |         |          |
|        | g01  | 1        |        |          |          |          | A2   | B2   | C2   |          |         |          |
|        | g02  |          |        |          |          |          |      |      |      |          |         |          |

dws.app_trf_agr_user<br />

## 流量基础指标多维报表

### 需求

#### 度量值

pv数<br />uv数<br />session数<br />访问时长<br />回头客数<br />跳出次数（只访问了一个页面就结束的会话）<br />跳出人数<br />

#### 维度

地域维度<br />时段维度<br />手机型号维度<br />操作系统维度<br />入口页面维度<br />跳出页面维度<br />新老属性维度<br /><br />

### 模型设计

目标表模型：<br />

| 省   | 市   | 区   | 手机型号 | 操作系统 | 入口页 | 跳出页 | 新老 | 小时段 | pv数 | uv   | 回头客 | 会话数 | 访问时长 | 跳出次数 |
| ---- | ---- | ---- | -------- | -------- | ------ | ------ | ---- | ------ | ---- | ---- | ------ | ------ | -------- | -------- |
| 江西 | \n   | \n   | \n       | \n       | \n     | \n     |      | \n     | 1000 |      |        |        |          |          |
| 江苏 | \n   | \n   | \n       | \n       | \n     | \n     |      | \n     | 1500 |      |        |        |          |          |
| 河南 | \n   | \n   | \n       | \n       | \n     | \n     |      | \n     | 1800 |      |        |        |          |          |
| ……   |      |      |          |          |        |        |      |        |      |      |        |        |          |          |
| 安徽 | \n   | \n   | \n       | \n       | \n     | \n     |      | \n     | 2000 |      |        |        |          |          |
| 江西 | 九江 | \n   | \n       | \n       | \n     | \n     |      | \n     | 800  |      |        |        |          |          |
| 江西 | 赣州 | \n   | \n       | \n       | \n     | \n     |      | \n     | 600  |      |        |        |          |          |
| 江西 | 南昌 | \n   | \n       | \n       | \n     | \n     |      | \n     | 450  |      |        |        |          |          |
| 江西 | ……   | \n   | \n       | \n       | \n     | \n     |      | \n     | 550  |      |        |        |          |          |
| 江苏 | 南通 | \n   | \n       | \n       | \n     | \n     |      | \n     | 660  |      |        |        |          |          |
| 江苏 | 苏州 | \n   | \n       | \n       | \n     | \n     |      | \n     | 540  |      |        |        |          |          |
| 江苏 | 徐州 | \n   | \n       | \n       | \n     | \n     |      | \n     | 400  |      |        |        |          |          |
| 浙江 | ……   | \n   | \n       | \n       | \n     | \n     |      | \n     | 320  |      |        |        |          |          |
| 浙江 | 温州 | \n   | \n       | \n       | \n     | \n     |      | \n     | 220  |      |        |        |          |          |
| \n   | \n   | \n   | MI6      | \n       | \n     | \n     |      | \n     | 1500 |      |        |        |          |          |
| \n   | \n   | \n   | MI8      | \n       | \n     | \n     |      | \n     | 2200 |      |        |        |          |          |
| \n   | \n   | \n   | MATE10   | \n       | \n     | \n     |      | \n     | 1800 |      |        |        |          |          |
| \n   | \n   | \n   | IPHONE6  | \n       | \n     | \n     |      | \n     | 1200 |      |        |        |          |          |
| \n   | \n   | \n   | ……       | \n       | \n     | \n     |      | \n     | ……   |      |        |        |          |          |
|      |      |      |          |          |        |        |      |        |      |      |        |        |          |          |


### 利用bitmap思想实现distinct的层级聚合

用户聚合表

```
"1,江苏省,南通市,下关区",
"1,江苏省,南通市,下关区",
"2,江苏省,南通市,下关区",
"2,江苏省,南通市,白领区",
"3,江苏省,南通市,白领区",
"3,江苏省,南通市,富豪区",
"1,江苏省,苏州市,园林区",
"1,江苏省,苏州市,园林区",
"4,江苏省,苏州市,虎跳区"
```

<br />基础分组表：聚合省-市-区分组

```
省，   市，   区，   人数（bitmap）
江苏省,南通市,下关区, [1,1,0,0]
江苏省,南通市,白领区, [0,1,1,0]  
江苏省,南通市,富豪区, [0,0,1,0]  
江苏省,苏州市,园林区, [1,0,0,0]  
江苏省,苏州市,虎跳区, [0,0,0,1]
```

聚合省-市分组

```
省，    市，   人数（bitmap）
江苏省,南通市, [1,1,1,0]   
江苏省,苏州市,  [1,0,0,1]
```

聚合省分组

```
省，      人数（bitmap）
江苏省,   [1,1,1,1]
```

<br />逐级聚合（去重聚合计算）<br /><br />在具体实现上，我们项目中采用了一个第三方的bitmap工具包：RoaringBitmap<br />然后为其开发了一系列的工具：

- array[Int] -> bitmap
- bitmap序列化
- bitmap反序列化
- bitmap的UDAF实现分组聚合or运算
- bitmap求基数的UDF

<br />

## 事件多维聚合分析

### 交互事件轻度聚合表

| 终端渠道 | 商品品类 | 商品品牌 | 所在页面 | 所属栏目 | 地域（省） | 地域（市） | 地域（区） | 时段 | 设备类型 | 点赞次数 | 点赞人数 | 收藏次数 | 收藏人数 |      |      | ……   |
| -------- | -------- | -------- | -------- | -------- | ---------- | ---------- | ---------- | ---- | -------- | -------- | -------- | -------- | -------- | ---- | ---- | ---- |
| app      |          |          |          |          |            |            |            |      |          |          |          |          |          |      |      |      |
| app      |          |          |          |          |            |            |            |      |          |          |          |          |          |      |      |      |
| wxapp    |          |          |          |          |            |            |            |      |          |          |          |          |          |      |      |      |
| wxapp    |          |          |          |          |            |            |            |      |          |          |          |          |          |      |      |      |
| H5       |          |          |          |          |            |            |            |      |          |          |          |          |          |      |      |      |

<br />

### 分享转发事件轻度聚合表

| 终端渠道 | 商品品类 | 商品品牌 | 所在页面 | 所属栏目 | 分享平台 | 时段 | 设备类型 | 分享人数 | 分享次数 | 二维码扫码 | 二维码扫码 | 转发次数 | 转发人数 |      |      | ……   |
| -------- | -------- | -------- | -------- | -------- | -------- | ---- | -------- | -------- | -------- | ---------- | ---------- | -------- | -------- | ---- | ---- | ---- |
| app      |          |          |          |          |          |      |          |          |          |            |            |          |          |      |      |      |
| app      |          |          |          |          |          |      |          |          |          |            |            |          |          |      |      |      |
| wxapp    |          |          |          |          |          |      |          |          |          |            |            |          |          |      |      |      |
| wxapp    |          |          |          |          |          |      |          |          |          |            |            |          |          |      |      |      |
| H5       |          |          |          |          |          |      |          |          |          |            |            |          |          |      |      |      |


### 交易事件轻度聚合表（不光有app的，也有微信的）

| 终<br />端<br />渠<br />道 | 商品品类 | 商品品牌 | 订单类型     | 时<br />段 | 设备类型 | 支付方式 | 是否用券 | 是否用红包 | 是否团购 | 是否拼单 | 广告来源 | 加购次数 | 加购人数 | 提交订单次数 | 提交订单人数 | 支付次数 | 支付人数 | ……   |
| -------------------------- | -------- | -------- | ------------ | ---------- | -------- | -------- | -------- | ---------- | -------- | -------- | -------- | -------- | -------- | ------------ | ------------ | -------- | -------- | ---- |
| app                        |          |          | 普通订单     |            |          |          |          |            |          |          |          |          |          |              |              |          |          |      |
| app                        |          |          | 秒杀订单     |            |          |          |          |            |          |          |          |          |          |              |              |          |          |      |
| wxapp                      |          |          | 促销活动订单 |            |          |          |          |            |          |          |          |          |          |              |              |          |          |      |
| wxapp                      |          |          |              |            |          |          |          |            |          |          |          |          |          |              |              |          |          |      |
| H5                         |          |          |              |            |          |          |          |            |          |          |          |          |          |              |              |          |          |      |


### 运营位、广告事件轻度聚合表

| 终<br />端<br />渠<br />道 | 运营位名称 | 运营位所在页面 | 所属广告系列 | 所属广告名称 | 所属广告的类型 | 商品品类 | 商品品牌 | 省市区 | 时间段 | 手机型号 | 操作系统 | 分辨率 | 用户<br />会员等级 | 用户年龄段 | 用户性别 | 用户消费频次 | ……   | ……   |
| -------------------------- | ---------- | -------------- | ------------ | ------------ | -------------- | -------- | -------- | ------ | ------ | -------- | -------- | ------ | ------------------ | ---------- | -------- | ------------ | ---- | ---- |
| app                        |            |                | 普通订单     |              |                |          |          |        |        |          |          |        |                    |            |          |              |      |      |
| app                        |            |                | 秒杀订单     |              |                |          |          |        |        |          |          |        |                    |            |          |              |      |      |
| wxapp                      |            |                | 促销活动订单 |              |                |          |          |        |        |          |          |        |                    |            |          |              |      |      |
| wxapp                      |            |                |              |              |                |          |          |        |        |          |          |        |                    |            |          |              |      |      |
| H5                         |            |                |              |              |                |          |          |        |        |          |          |        |                    |            |          |              |      |      |

<br />上述所有求分组后聚合去重人数的指标，统统采用bitmap数据结构来存储！<br /><br /><br /><br />

## 活跃分析（方案1）：拉链表

### 需求说明

分析用户的活跃度，比如，查询任意时间窗口内的连续N天活跃、沉默用户，人数等

### 主体逻辑

要查询5/6/7/8号连续活跃的用户，可以用<br />

```
5号的日活guid
  join 
6号的日活guid 
join
7号的日活guid
join
8号的日活guid
```

这种方法简单粗暴，但效率极低<br /><br />我们的最终做法有两套方案：<br />方案1：连续活跃区间记录表<br />方案2：活跃状态bitmap记录表

### 方案1模型设计

要做一张“连续活跃区间”记录表

#### 用户连续活跃区间记录（类似拉链表）

| 计算日期 | 首访日期   | guid | 连续活跃起始日 | 连续活跃结束日 |
| -------- | ---------- | ---- | -------------- | -------------- |
|          | 2020-09-01 | G01  | 2020-09-01     | 2020-09-03     |
|          | 2020-09-01 | G01  | 2020-09-06     | 9999-12-31     |
|          | 2020-09-01 | G02  | 2020-09-01     | 2020-09-03     |
|          | 2020-09-01 | G03  | 2020-09-01     | 2020-09-03     |
|          | 2020-09-01 | G03  | 2020-09-09     | 9999-12-31     |
|          | 2020-09-02 |      | 2020-09-02     | 2020-09-03     |
|          | 2020-09-02 |      | 2020-09-02     | 2020-09-03     |
|          | 2020-09-02 |      | 2020-09-09     | 9999-12-31     |

dws.app_user_active_range<br />这个表的核心思想： 记录着每个人的每天活跃信息，但是又不用每天都存储一条记录！

### 方案1实现逻辑

拿着T-1日的“连续活跃区间记录表” FULL JOIN 日活T日<br />用9999-12-31表示持续到今天，可以有效的减少表的日常更新写入<br />_逻辑：新来的插入、没来的更新 endTime 、一直就在的不用管、老客新来的插入新纪录_<br />（1）处理现有记录：分情况取值：<br /> 所有非9999-12-31区间，不用做任何改变<br /> 对于9999-12-31区间，则看如下情况： <br />如果T-1日有，T日无，则区间结束日9999-12-31改成T-1（_没来的更新__endTime_）<br />如果T-1日有，T日有，则无需更改（_一直就在的不用管_）<br />对于历史上没有的新用户，则直接生成一条新的记录（_新来的插入_）<br /><br />（2）处理T-1日没有9999-12-31这种区间的人，而T日到访，则单独生成一条新纪录（_老客新来的插入新纪录：_FULL JOIN无法生成的）<br />最后将（1） UNION ALL （2）即得到最终更新后的T日连续区间记录表全量

### ADS活跃天数分布报表开发

核心点：<br /> 区间结束日 - 区间起始日  ==》 得到一个区间的持续天数

### ADS沉默天数分布报表开发

核心点：<br />利用了一个lead over的窗口函数，将一个用户的<br />下一个活跃区间起始 - 上一个活跃区间结束 ==》 得到沉默天数

## 活跃分析（方案2）：bitmap结构

利用bitmap结构来记录一个用户在每天的活跃状态（最近一个月）<br />

| 计算日期   | guid | 最近31日（含当日）的活跃记录bit数组 |
| ---------- | ---- | ----------------------------------- |
| 2020-12-19 | g001 | 100101011010111101101001010110      |
| 2020-12-19 | g002 | 001111011010101101101001110111      |
| 2020-12-19 | g003 | 001111011010101010011001110111      |
| 2020-12-19 | g004 | 101111011010101100001001110111      |
| 2020-12-19 | g005 | 111110110101011011010011101110      |

<br />表中的bit数组字段：<br />l 脚标，代表距“now day”的天数，比如，<br />第1个bit，就是距当天0日前；<br />第2个bit，就是距当天1日前；<br />……<br />l value值，代表用户在该脚标所指示日期上的活跃状态，0表示没有活跃，1表示有活跃<br /><br />该表的本质： 记录了最近N天（31）内，每个用户的每天的活跃状态；<br />形式简单直观；存储效率高！

## 新用户留存分析

### 需求说明

查询任意指定日期的新用户，在1日后，2日后，3日后……的活跃留存<br />如下，为一个典型的“新用户留存”分析表

| 首访日期   | DNU  | 次日留存 | 2日留存 | 3日留存 | 4日留存 | 5日留存 | 6日留存 |
| ---------- | ---- | -------- | ------- | ------- | ------- | ------- | ------- |
| 2020-07-01 | 1500 | 1000     | 1200    | 800     | 600     | 450     | 300     |
| 2020-07-02 | 2000 | 1000     | 800     | 600     | 400     | 290     |         |
| 2020-07-03 | 1800 | 1200     | 900     | 1000    | 980     |         |         |
| 2020-07-04 | 3000 | 2500     | 1200    | 1050    |         |         |         |
| 2020-07-05 | 2500 | 900      | 880     |         |         |         |         |
| 2020-07-06 | 1200 | 800      |         |         |         |         |         |
| 2020-07-07 | 900  |          |         |         |         |         |         |

****<br />**计算要点： **<br />l 每日滚动计算<br />l 每天计算“x日->计算日” 的留存数即可<br /><br />对上述方案略微修改，做一个竖表更方便：<br />上述横表形式的报表不方便直接计算，可设计如下纵表（竖表）作为中间表<br />l dws.retention_newuser_active

| 计算日期       | 留存起始日期   | 留存天数 | 留存人数 |
| -------------- | -------------- | -------- | -------- |
| **2020-09-09** | **2020-09-08** | **1**    | 124      |
| 2020-09-09     | 2020-09-07     | 2        | 235      |
| 2020-09-09     | 2020-09-06     | 3        |          |
| 2020-09-09     | 2020-09-05     | 4        |          |
| 2020-09-09     | 2020-09-04     | 5        |          |
| 2020-09-09     | 2020-09-03     | 6        |          |
| 2020-09-09     | 2020-09-02     | 7        |          |
| 2020-09-09     | 2020-09-01     | 8        |          |
|                | ........       |          |          |
| 2020-09-09     | 2020-08-09     | 30       |          |
| 2020-09-10     | 2020-09-09     | 1        |          |
| **2020-09-10** | **2020-09-08** | **2**    |          |
| 2020-09-10     | 2020-09-07     | 3        |          |
| 2020-09-10     |                |          |          |
| 2020-09-10     |                |          |          |
| 2020-09-10     |                |          |          |
| 2020-09-10     | ......         |          |          |
| 2020-09-10     | 2020-08-10     | 30       |          |


### 主体逻辑

方案一：拉链表解决<br />1、从“连续活跃区间记录表”中，提取出所有区间结束时间=9999-12-31的数据（代表在计算日活跃的用户）<br />2、对提取出的数据，当日 - 首访日 = 留存天数<br />3、按照留存天数分组，统计人数（留存人数）<br /><br />方案二：bitmap解决（只取29天留存）<br />1、从“用户活跃状态bitmap记录表”，提取出所以bitmap尾号为1（奇数判断 %2=1）（代表在计算日活跃的用户）<br />2、对提取出的数据，当日 - 首访日 = 留存天数<br />3、按照留存天数分组，统计人数（留存人数）

## 漏斗分析

### 需求说明

根据需求方定义的业务路径（各种各样），统计每个步骤上的完成人数

### 主体逻辑

1、从事件明细表中，过滤出符合业务路径定义条件的事件数据<br />2、根据guid分组，时间先后排序，收集到一个数组中，并拼接成字符串<br />3、利用正则表达式，来判断用户完成到的最大步骤<br />

## 思想总结

维度组合聚合思想（数据立方体cube）<br />高阶聚合函数（with cube / grouping sets / with rollup）<br />Bitmap思想<br />建模思想：<br />维度模型（星型模型、雪花模型、星座模型）<br />三范式模型






